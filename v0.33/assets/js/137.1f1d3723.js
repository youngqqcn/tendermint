(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{732:function(e,t,n){"use strict";n.r(t);var o=n(1),i=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"basic-concepts-and-definitions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#basic-concepts-and-definitions"}},[e._v("#")]),e._v(" Basic concepts and definitions")]),e._v(" "),n("h2",{attrs:{id:"connections"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#connections"}},[e._v("#")]),e._v(" Connections")]),e._v(" "),n("p",[e._v("ABCI++ applications can run either within the "),n("em",[e._v("same")]),e._v(" process as the Tendermint\nstate-machine replication engine, or as a "),n("em",[e._v("separate")]),e._v(" process from the state-machine\nreplication engine. When run within the same process, Tendermint will call the ABCI++\napplication methods directly as Go method calls.")]),e._v(" "),n("p",[e._v("When Tendermint and the ABCI++ application are run as separate processes, Tendermint\nopens four connections to the application for ABCI++ methods. The connections each\nhandle a subset of the ABCI++ method calls. These subsets are defined as follows:")]),e._v(" "),n("h3",{attrs:{id:"consensus-connection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#consensus-connection"}},[e._v("#")]),e._v(" "),n("strong",[e._v("Consensus")]),e._v(" connection")]),e._v(" "),n("ul",[n("li",[e._v("Driven by a consensus protocol and is responsible for block execution.")]),e._v(" "),n("li",[e._v("Handles the "),n("code",[e._v("InitChain")]),e._v(", "),n("code",[e._v("PrepareProposal")]),e._v(", "),n("code",[e._v("ProcessProposal")]),e._v(", "),n("code",[e._v("ExtendVote")]),e._v(",\n"),n("code",[e._v("VerifyVoteExtension")]),e._v(", and "),n("code",[e._v("FinalizeBlock")]),e._v(" method calls.")])]),e._v(" "),n("h3",{attrs:{id:"mempool-connection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mempool-connection"}},[e._v("#")]),e._v(" "),n("strong",[e._v("Mempool")]),e._v(" connection")]),e._v(" "),n("ul",[n("li",[e._v("For validating new transactions, before they're shared or included in a block.")]),e._v(" "),n("li",[e._v("Handles the "),n("code",[e._v("CheckTx")]),e._v(" calls.")])]),e._v(" "),n("h3",{attrs:{id:"info-connection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#info-connection"}},[e._v("#")]),e._v(" "),n("strong",[e._v("Info")]),e._v(" connection")]),e._v(" "),n("ul",[n("li",[e._v("For initialization and for queries from the user.")]),e._v(" "),n("li",[e._v("Handles the "),n("code",[e._v("Info")]),e._v(" and "),n("code",[e._v("Query")]),e._v(" calls.")])]),e._v(" "),n("h3",{attrs:{id:"snapshot-connection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#snapshot-connection"}},[e._v("#")]),e._v(" "),n("strong",[e._v("Snapshot")]),e._v(" connection")]),e._v(" "),n("ul",[n("li",[e._v("For serving and restoring "),n("RouterLink",{attrs:{to:"/spec/abci/apps.html#state-sync"}},[e._v("state sync snapshots")]),e._v(".")],1),e._v(" "),n("li",[e._v("Handles the "),n("code",[e._v("ListSnapshots")]),e._v(", "),n("code",[e._v("LoadSnapshotChunk")]),e._v(", "),n("code",[e._v("OfferSnapshot")]),e._v(", and "),n("code",[e._v("ApplySnapshotChunk")]),e._v(" calls.")])]),e._v(" "),n("p",[e._v("Additionally, there is a "),n("code",[e._v("Flush")]),e._v(" method that is called on every connection,\nand an "),n("code",[e._v("Echo")]),e._v(" method that is just for debugging.")]),e._v(" "),n("blockquote",[n("p",[n("strong",[e._v("TODO")]),e._v(" Figure out what to do with this.")])]),e._v(" "),n("p",[e._v("More details on managing state across connections can be found in the section on\n"),n("RouterLink",{attrs:{to:"/spec/abci/apps.html"}},[e._v("ABCI Applications")]),e._v(".")],1),e._v(" "),n("h2",{attrs:{id:"errors"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#errors"}},[e._v("#")]),e._v(" Errors")]),e._v(" "),n("p",[e._v("The "),n("code",[e._v("Query")]),e._v(", and "),n("code",[e._v("CheckTx")]),e._v(" methods include a "),n("code",[e._v("Code")]),e._v(" field in their "),n("code",[e._v("Response*")]),e._v(".\nThe "),n("code",[e._v("Code")]),e._v(" field is also included in type "),n("code",[e._v("TxResult")]),e._v(", used by\nmethod "),n("code",[e._v("FinalizeBlock")]),e._v("'s "),n("code",[e._v("Response*")]),e._v(".\nField "),n("code",[e._v("Code")]),e._v(" is meant to contain an application-specific response code.\nA response code of "),n("code",[e._v("0")]),e._v(" indicates no error.  Any other response code\nindicates to Tendermint that an error occurred.")]),e._v(" "),n("p",[e._v("These methods also return a "),n("code",[e._v("Codespace")]),e._v(" string to Tendermint. This field is\nused to disambiguate "),n("code",[e._v("Code")]),e._v(" values returned by different domains of the\nApplication. The "),n("code",[e._v("Codespace")]),e._v(" is a namespace for the "),n("code",[e._v("Code")]),e._v(".")]),e._v(" "),n("p",[e._v("Methods "),n("code",[e._v("Echo")]),e._v(", "),n("code",[e._v("Info")]),e._v(", and "),n("code",[e._v("InitChain")]),e._v(" do not return errors.\nAn error in any of these methods represents a critical issue that Tendermint\nhas no reasonable way to handle. If there is an error in one\nof these methods, the Application must crash to ensure that the error is safely\nhandled by an operator.")]),e._v(" "),n("p",[e._v("Method "),n("code",[e._v("FinalizeBlock")]),e._v(" is a special case. It contains a number of\n"),n("code",[e._v("Code")]),e._v(" and "),n("code",[e._v("Codespace")]),e._v(" fields as part of type "),n("code",[e._v("TxResult")]),e._v(". Each of\nthese codes reports errors related to the transaction it is attached to.\nHowever, "),n("code",[e._v("FinalizeBlock")]),e._v(" does not return errors at the top level, so the\nsame considerations on critical issues made for "),n("code",[e._v("Echo")]),e._v(", "),n("code",[e._v("Info")]),e._v(", and\n"),n("code",[e._v("InitChain")]),e._v(" also apply here.")]),e._v(" "),n("p",[e._v("The handling of non-zero response codes by Tendermint is described below")]),e._v(" "),n("h3",{attrs:{id:"checktx"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#checktx"}},[e._v("#")]),e._v(" "),n("code",[e._v("CheckTx")])]),e._v(" "),n("p",[e._v("The "),n("code",[e._v("CheckTx")]),e._v(" ABCI++ method controls what transactions are considered for inclusion\nin a block.\nWhen Tendermint receives a "),n("code",[e._v("ResponseCheckTx")]),e._v(" with a non-zero "),n("code",[e._v("Code")]),e._v(", the associated\ntransaction will not be added to Tendermint's mempool or it will be removed if\nit is already included.")]),e._v(" "),n("h3",{attrs:{id:"txresult-as-part-of-finalizeblock"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#txresult-as-part-of-finalizeblock"}},[e._v("#")]),e._v(" "),n("code",[e._v("TxResult")]),e._v(" (as part of "),n("code",[e._v("FinalizeBlock")]),e._v(")")]),e._v(" "),n("p",[e._v("The "),n("code",[e._v("TxResult")]),e._v(" type delivers transactions from Tendermint to the Application.\nWhen Tendermint receives a "),n("code",[e._v("ResponseFinalizeBlock")]),e._v(" containing a "),n("code",[e._v("TxResult")]),e._v("\nwith a non-zero "),n("code",[e._v("Code")]),e._v(", the response code is logged.\nThe transaction was already included in a block, so the "),n("code",[e._v("Code")]),e._v(" does not influence\nTendermint consensus.")]),e._v(" "),n("h3",{attrs:{id:"query"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#query"}},[e._v("#")]),e._v(" "),n("code",[e._v("Query")])]),e._v(" "),n("p",[e._v("The "),n("code",[e._v("Query")]),e._v(" ABCI++ method queries the Application for information about application state.\nWhen Tendermint receives a "),n("code",[e._v("ResponseQuery")]),e._v(" with a non-zero "),n("code",[e._v("Code")]),e._v(", this code is\nreturned directly to the client that initiated the query.")]),e._v(" "),n("h2",{attrs:{id:"events"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#events"}},[e._v("#")]),e._v(" Events")]),e._v(" "),n("p",[e._v("Method "),n("code",[e._v("CheckTx")]),e._v(" includes an "),n("code",[e._v("Events")]),e._v(" field in its "),n("code",[e._v("Response*")]),e._v(".\nMethod "),n("code",[e._v("FinalizeBlock")]),e._v(" includes an "),n("code",[e._v("Events")]),e._v(" field at the top level in its\n"),n("code",[e._v("Response*")]),e._v(", and one "),n("code",[e._v("tx_events")]),e._v(" field per transaction included in the block.\nApplications may respond to these ABCI++ methods with a set of events.\nEvents allow applications to associate metadata about ABCI++ method execution with the\ntransactions and blocks this metadata relates to.\nEvents returned via these ABCI++ methods do not impact Tendermint consensus in any way\nand instead exist to power subscriptions and queries of Tendermint state.")]),e._v(" "),n("p",[e._v("An "),n("code",[e._v("Event")]),e._v(" contains a "),n("code",[e._v("type")]),e._v(" and a list of "),n("code",[e._v("EventAttributes")]),e._v(", which are key-value\nstring pairs denoting metadata about what happened during the method's (or transaction's)\nexecution. "),n("code",[e._v("Event")]),e._v(" values can be used to index transactions and blocks according to what\nhappened during their execution.")]),e._v(" "),n("p",[e._v("Each event has a "),n("code",[e._v("type")]),e._v(" which is meant to categorize the event for a particular\n"),n("code",[e._v("Response*")]),e._v(" or "),n("code",[e._v("Tx")]),e._v(". A "),n("code",[e._v("Response*")]),e._v(" or "),n("code",[e._v("Tx")]),e._v(" may contain multiple events with duplicate\n"),n("code",[e._v("type")]),e._v(" values, where each distinct entry is meant to categorize attributes for a\nparticular event. Every key and value in an event's attributes must be UTF-8\nencoded strings along with the event type itself.")]),e._v(" "),n("tm-code-block",{staticClass:"codeblock",attrs:{language:"protobuf",base64:"bWVzc2FnZSBFdmVudCB7CiAgc3RyaW5nICAgICAgICAgICAgICAgICAgdHlwZSAgICAgICA9IDE7CiAgcmVwZWF0ZWQgRXZlbnRBdHRyaWJ1dGUgYXR0cmlidXRlcyA9IDI7Cn0K"}}),e._v(" "),n("p",[e._v("The attributes of an "),n("code",[e._v("Event")]),e._v(" consist of a "),n("code",[e._v("key")]),e._v(", a "),n("code",[e._v("value")]),e._v(", and an "),n("code",[e._v("index")]),e._v(" flag. The\nindex flag notifies the Tendermint indexer to index the attribute. The value of\nthe "),n("code",[e._v("index")]),e._v(" flag is non-deterministic and may vary across different nodes in the network.")]),e._v(" "),n("tm-code-block",{staticClass:"codeblock",attrs:{language:"protobuf",base64:"bWVzc2FnZSBFdmVudEF0dHJpYnV0ZSB7CiAgYnl0ZXMga2V5ICAgPSAxOwogIGJ5dGVzIHZhbHVlID0gMjsKICBib29sICBpbmRleCA9IDM7ICAvLyBub25kZXRlcm1pbmlzdGljCn0K"}}),e._v(" "),n("p",[e._v("Example:")]),e._v(" "),n("tm-code-block",{staticClass:"codeblock",attrs:{language:"go",base64:"IGFiY2kuUmVzcG9uc2VDaGVja1R4ewogIC8vIC4uLgogRXZlbnRzOiBbXWFiY2kuRXZlbnR7CiAgewogICBUeXBlOiAmcXVvdDt2YWxpZGF0b3IucHJvdmlzaW9ucyZxdW90OywKICAgQXR0cmlidXRlczogW11hYmNpLkV2ZW50QXR0cmlidXRlewogICAgYWJjaS5FdmVudEF0dHJpYnV0ZXtLZXk6IFtdYnl0ZSgmcXVvdDthZGRyZXNzJnF1b3Q7KSwgVmFsdWU6IFtdYnl0ZSgmcXVvdDsuLi4mcXVvdDspLCBJbmRleDogdHJ1ZX0sCiAgICBhYmNpLkV2ZW50QXR0cmlidXRle0tleTogW11ieXRlKCZxdW90O2Ftb3VudCZxdW90OyksIFZhbHVlOiBbXWJ5dGUoJnF1b3Q7Li4uJnF1b3Q7KSwgSW5kZXg6IHRydWV9LAogICAgYWJjaS5FdmVudEF0dHJpYnV0ZXtLZXk6IFtdYnl0ZSgmcXVvdDtiYWxhbmNlJnF1b3Q7KSwgVmFsdWU6IFtdYnl0ZSgmcXVvdDsuLi4mcXVvdDspLCBJbmRleDogdHJ1ZX0sCiAgIH0sCiAgfSwKICB7CiAgIFR5cGU6ICZxdW90O3ZhbGlkYXRvci5wcm92aXNpb25zJnF1b3Q7LAogICBBdHRyaWJ1dGVzOiBbXWFiY2kuRXZlbnRBdHRyaWJ1dGV7CiAgICBhYmNpLkV2ZW50QXR0cmlidXRle0tleTogW11ieXRlKCZxdW90O2FkZHJlc3MmcXVvdDspLCBWYWx1ZTogW11ieXRlKCZxdW90Oy4uLiZxdW90OyksIEluZGV4OiB0cnVlfSwKICAgIGFiY2kuRXZlbnRBdHRyaWJ1dGV7S2V5OiBbXWJ5dGUoJnF1b3Q7YW1vdW50JnF1b3Q7KSwgVmFsdWU6IFtdYnl0ZSgmcXVvdDsuLi4mcXVvdDspLCBJbmRleDogZmFsc2V9LAogICAgYWJjaS5FdmVudEF0dHJpYnV0ZXtLZXk6IFtdYnl0ZSgmcXVvdDtiYWxhbmNlJnF1b3Q7KSwgVmFsdWU6IFtdYnl0ZSgmcXVvdDsuLi4mcXVvdDspLCBJbmRleDogZmFsc2V9LAogICB9LAogIH0sCiAgewogICBUeXBlOiAmcXVvdDt2YWxpZGF0b3Iuc2xhc2hlZCZxdW90OywKICAgQXR0cmlidXRlczogW11hYmNpLkV2ZW50QXR0cmlidXRlewogICAgYWJjaS5FdmVudEF0dHJpYnV0ZXtLZXk6IFtdYnl0ZSgmcXVvdDthZGRyZXNzJnF1b3Q7KSwgVmFsdWU6IFtdYnl0ZSgmcXVvdDsuLi4mcXVvdDspLCBJbmRleDogZmFsc2V9LAogICAgYWJjaS5FdmVudEF0dHJpYnV0ZXtLZXk6IFtdYnl0ZSgmcXVvdDthbW91bnQmcXVvdDspLCBWYWx1ZTogW11ieXRlKCZxdW90Oy4uLiZxdW90OyksIEluZGV4OiB0cnVlfSwKICAgIGFiY2kuRXZlbnRBdHRyaWJ1dGV7S2V5OiBbXWJ5dGUoJnF1b3Q7cmVhc29uJnF1b3Q7KSwgVmFsdWU6IFtdYnl0ZSgmcXVvdDsuLi4mcXVvdDspLCBJbmRleDogdHJ1ZX0sCiAgIH0sCiAgfSwKICAvLyAuLi4KIH0sCn0K"}}),e._v(" "),n("h2",{attrs:{id:"evidencetype"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#evidencetype"}},[e._v("#")]),e._v(" EvidenceType")]),e._v(" "),n("p",[e._v('Tendermint\'s security model relies on the use of "evidence". Evidence is proof of\nmalicious behaviour by a network participant. It is the responsibility of Tendermint\nto detect such malicious behaviour. When malicious behavior is detected, Tendermint\nwill gossip evidence of the behavior to other nodes and commit the evidence to\nthe chain once it is verified by all validators. This evidence will then be\npassed on to the Application through ABCI++. It is the responsibility of the\nApplication to handle the evidence and exercise punishment.')]),e._v(" "),n("p",[e._v("EvidenceType has the following protobuf format:")]),e._v(" "),n("tm-code-block",{staticClass:"codeblock",attrs:{language:"protobuf",base64:"ZW51bSBFdmlkZW5jZVR5cGUgewogIFVOS05PV04gICAgICAgICAgICAgICA9IDA7CiAgRFVQTElDQVRFX1ZPVEUgICAgICAgID0gMTsKICBMSUdIVF9DTElFTlRfQVRUQUNLICAgPSAyOwp9Cg=="}}),e._v(" "),n("p",[e._v("There are two forms of evidence: Duplicate Vote and Light Client Attack. More\ninformation can be found in either "),n("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/spec/core/data_structures.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("data structures"),n("OutboundLink")],1),e._v("\nor "),n("a",{attrs:{href:"https://github.com/tendermint/spec/blob/master/spec/light-client/accountability/",target:"_blank",rel:"noopener noreferrer"}},[e._v("accountability"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"vote-extensions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vote-extensions"}},[e._v("#")]),e._v(" Vote Extensions")]),e._v(" "),n("p",[e._v("According to the Tendermint algorithm, a proposed block needs at least a predefined\nnumber of precommit votes in order to be decided. Tendermint gathers all the valid\nprecommit votes for the decided block that it receives before the block is decided,\nand then includes these votes in the proposed block for the next height whenever\nthe local process is the proposer of the round.")]),e._v(" "),n("p",[e._v("When Tendermint's consensus is about to send a non-"),n("code",[e._v("nil")]),e._v(" precommit message, it calls\nmethod "),n("code",[e._v("ExtendVote")]),e._v(", which gives the Application the opportunity to include\nnon-deterministic data, opaque to Tendermint, that will be attached to the precommit\nmessage. The data, called "),n("em",[e._v("vote extension")]),e._v(", will also be part of the proposed block\nin the next height, along with the vote it is extending.")]),e._v(" "),n("p",[e._v("The vote extension data is split into two parts, one signed by Tendermint as part\nof the vote data structure, and the other (optionally) signed by the Application.\nThe Application may also choose not to include any vote extension.\nWhen another process receives a precommit message with a vote extension, it calls\nmethod "),n("code",[e._v("VerifyVoteExtension")]),e._v(" so that the Application can validate the data received.\nIf the validation fails, the precommit message will be deemed invalid and ignored\nby Tendermint. This has negative impact on Tendermint's liveness, i.e., if repeatedly vote extensions by correct validators cannot be verified by correct validators, Tendermint may not be able to finalize a block even if sufficiently many (+2/3) of the validators send precommit votes for that block. Thus, "),n("code",[e._v("VerifyVoteExtension")]),e._v(" should only be used with special care.\nAs a general rule, an Application that detects an invalid vote extension SHOULD\naccept it in "),n("code",[e._v("ResponseVerifyVoteExtension")]),e._v(" and ignore it in its own logic.")]),e._v(" "),n("h2",{attrs:{id:"determinism"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#determinism"}},[e._v("#")]),e._v(" Determinism")]),e._v(" "),n("p",[e._v("ABCI++ applications must implement deterministic finite-state machines to be\nsecurely replicated by the Tendermint consensus engine. This means block execution\nover the Consensus Connection must be strictly deterministic: given the same\nordered set of requests, all nodes will compute identical responses, for all\nsuccessive "),n("code",[e._v("FinalizeBlock")]),e._v(" calls. This is critical, because the\nresponses are included in the header of the next block, either via a Merkle root\nor directly, so all nodes must agree on exactly what they are.")]),e._v(" "),n("p",[e._v("For this reason, it is recommended that applications not be exposed to any\nexternal user or process except via the ABCI connections to a consensus engine\nlike Tendermint Core. The Application must only change its state based on input\nfrom block execution ("),n("code",[e._v("FinalizeBlock")]),e._v(" calls), and not through\nany other kind of request. This is the only way to ensure all nodes see the same\ntransactions and compute the same results.")]),e._v(" "),n("p",[e._v("Some Applications may choose to execute the blocks that are about to be proposed\n(via "),n("code",[e._v("PrepareProposal")]),e._v("), or those that the Application is asked to validate\n(via "),n("code",[e._v("Processproposal")]),e._v("). However the state changes caused by processing those\nproposed blocks must never replace the previous state until "),n("code",[e._v("FinalizeBlock")]),e._v(" confirms\nthe block decided.")]),e._v(" "),n("p",[e._v("Additionally, vote extensions or the validation thereof (via "),n("code",[e._v("ExtendVote")]),e._v(" or\n"),n("code",[e._v("VerifyVoteExtension")]),e._v(") must "),n("em",[e._v("never")]),e._v(" have side effects on the current state.\nThey can only be used when their data is included in a block.")]),e._v(" "),n("p",[e._v("If there is some non-determinism in the state machine, consensus will eventually\nfail as nodes disagree over the correct values for the block header. The\nnon-determinism must be fixed and the nodes restarted.")]),e._v(" "),n("p",[e._v("Sources of non-determinism in applications may include:")]),e._v(" "),n("ul",[n("li",[e._v("Hardware failures\n"),n("ul",[n("li",[e._v("Cosmic rays, overheating, etc.")])])]),e._v(" "),n("li",[e._v("Node-dependent state\n"),n("ul",[n("li",[e._v("Random numbers")]),e._v(" "),n("li",[e._v("Time")])])]),e._v(" "),n("li",[e._v("Underspecification\n"),n("ul",[n("li",[e._v("Library version changes")]),e._v(" "),n("li",[e._v("Race conditions")]),e._v(" "),n("li",[e._v("Floating point numbers")]),e._v(" "),n("li",[e._v("JSON or protobuf serialization")]),e._v(" "),n("li",[e._v("Iterating through hash-tables/maps/dictionaries")])])]),e._v(" "),n("li",[e._v("External Sources\n"),n("ul",[n("li",[e._v("Filesystem")]),e._v(" "),n("li",[e._v("Network calls (eg. some external REST API service)")])])])]),e._v(" "),n("p",[e._v("See "),n("a",{attrs:{href:"https://github.com/tendermint/abci/issues/56",target:"_blank",rel:"noopener noreferrer"}},[e._v("#56"),n("OutboundLink")],1),e._v(" for original discussion.")]),e._v(" "),n("p",[e._v("Note that some methods ("),n("code",[e._v("Query, CheckTx, FinalizeBlock")]),e._v(") return\nexplicitly non-deterministic data in the form of "),n("code",[e._v("Info")]),e._v(" and "),n("code",[e._v("Log")]),e._v(" fields. The "),n("code",[e._v("Log")]),e._v(" is\nintended for the literal output from the Application's logger, while the\n"),n("code",[e._v("Info")]),e._v(" is any additional info that should be returned. These are the only fields\nthat are not included in block header computations, so we don't need agreement\non them. All other fields in the "),n("code",[e._v("Response*")]),e._v(" must be strictly deterministic.")]),e._v(" "),n("h2",{attrs:{id:"block-execution"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#block-execution"}},[e._v("#")]),e._v(" Block Execution")]),e._v(" "),n("p",[e._v("The first time a new blockchain is started, Tendermint calls\n"),n("code",[e._v("InitChain")]),e._v(". From then on, method "),n("code",[e._v("FinalizeBlock")]),e._v(" is executed at the end of each\nblock, resulting in an updated Application state.\nDuring consensus execution of a block height, before method "),n("code",[e._v("FinalizeBlock")]),e._v(" is\ncalled, methods "),n("code",[e._v("PrepareProposal")]),e._v(", "),n("code",[e._v("ProcessProposal")]),e._v(", "),n("code",[e._v("ExtendVote")]),e._v(", and\n"),n("code",[e._v("VerifyVoteExtension")]),e._v(" may be called a number of times.\nSee "),n("RouterLink",{attrs:{to:"/spec/abci++/abci++_tmint_expected_behavior_002_draft.html"}},[e._v("Tendermint's expected behavior")]),e._v("\nfor details on the possible call sequences of these methods.")],1),e._v(" "),n("p",[e._v("Method "),n("code",[e._v("PrepareProposal")]),e._v(" is called every time Tendermint is about to send\na proposal message, but no previous proposal has been locked at Tendermint level.\nTendermint gathers outstanding transactions from the mempool\n(see "),n("a",{attrs:{href:"#PrepareProposal"}},[e._v("PrepareProposal")]),e._v("), generates a block header and uses\nthem to create a block to propose. Then, it calls "),n("code",[e._v("RequestPrepareProposal")]),e._v("\nwith the newly created proposal, called "),n("em",[e._v("raw proposal")]),e._v(". The Application can\nmake changes to the raw proposal, such as modifying transactions, and returns\nthe (potentially) modified proposal, called "),n("em",[e._v("prepared proposal")]),e._v(" in the\n"),n("code",[e._v("Response*")]),e._v(" call. The logic modifying the raw proposal can be non-deterministic.")]),e._v(" "),n("p",[e._v("When Tendermint receives a prepared proposal it uses method "),n("code",[e._v("ProcessProposal")]),e._v("\nto inform the Application of the proposal just received. The Application cannot\nmodify the proposal at this point but can reject it if it realises it is invalid.\nIf that is the case, Tendermint will prevote "),n("code",[e._v("nil")]),e._v(" on the proposal, which has\nstrong liveness implications for Tendermint. As a general rule, the Application\nSHOULD accept a prepared proposal passed via "),n("code",[e._v("ProcessProposal")]),e._v(", even if a part of\nthe proposal is invalid (e.g., an invalid transaction); the Application can later\nignore the invalid part of the prepared proposal at block execution time.")]),e._v(" "),n("p",[e._v("Cryptographic commitments to the block and transaction results, via the corresponding\nparameters in "),n("code",[e._v("FinalizeBlockResponse")]),e._v(" are included in the header of the next block.")]),e._v(" "),n("h2",{attrs:{id:"next-block-execution-and-same-block-execution"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#next-block-execution-and-same-block-execution"}},[e._v("#")]),e._v(" Next-block execution and same-block execution")]),e._v(" "),n("p",[e._v("With ABCI++ predecessor, ABCI, the only moment when the Application had access to a\nblock was when it was decided. This led to a block execution model, called "),n("em",[e._v("next-block\nexecution")]),e._v(", where some fields hashed in a block header refer to the execution of the\nprevious block, namely:")]),e._v(" "),n("ul",[n("li",[e._v("the merkle root of the Application's state")]),e._v(" "),n("li",[e._v("the transaction results")]),e._v(" "),n("li",[e._v("the consensus parameter updates")]),e._v(" "),n("li",[e._v("the validator updates")])]),e._v(" "),n("p",[e._v("With ABCI++, an Application may decide to keep using the next-block execution model;\nhowever the new methods introduced, "),n("code",[e._v("PrepareProposal")]),e._v(" and "),n("code",[e._v("ProcessProposal")]),e._v(" allow\nfor a new execution model, called "),n("em",[e._v("same-block execution")]),e._v(". An Application implementing\nthis execution model, upon receiving a raw proposal via "),n("code",[e._v("RequestPrepareProposal")]),e._v("\nand potentially modifying its transaction list,\nfully executes the resulting prepared proposal as though it was the decided block.\nThe results of the block execution are used as follows:")]),e._v(" "),n("ul",[n("li",[e._v("the Application keeps the events generated and provides them if "),n("code",[e._v("FinalizeBlock")]),e._v("\nis finally called on this prepared proposal.")]),e._v(" "),n("li",[e._v("the merkle root resulting from executing the prepared proposal is provided in\n"),n("code",[e._v("ResponsePrepareProposal")]),e._v(" and thus refers to the "),n("strong",[e._v("current block")]),e._v(". Tendermint\nwill use it in the prepared proposal's header.")]),e._v(" "),n("li",[e._v("likewise, the transaction results from executing the prepared proposal are\nprovided in "),n("code",[e._v("ResponsePrepareProposal")]),e._v(" and refer to the transactions in the\n"),n("strong",[e._v("current block")]),e._v(". Tendermint will use them to calculate the results hash\nin the prepared proposal's header.")]),e._v(" "),n("li",[e._v("the consensus parameter updates and validator updates are also provided in\n"),n("code",[e._v("ResponsePrepareProposal")]),e._v(" and reflect the result of the prepared proposal's\nexecution. They come into force in height H+1 (as opposed to the H+2 rule\nin next-block execution model).")])]),e._v(" "),n("p",[e._v("If the Application decides to keep the next-block execution model, it will not\nprovide any data in "),n("code",[e._v("ResponsePrepareProposal")]),e._v(", other than an optionally modified\ntransaction list.")]),e._v(" "),n("p",[e._v("In the long term, the execution model will be set in a new boolean parameter\n"),n("em",[e._v("same_block")]),e._v(" in "),n("code",[e._v("ConsensusParams")]),e._v(".\nIt should "),n("strong",[e._v("not")]),e._v(" be changed once the blockchain has started, unless the Application\ndevelopers "),n("em",[e._v("really")]),e._v(" know what they are doing.\nHowever, modifying "),n("code",[e._v("ConsensusParams")]),e._v(" structure cannot be done lightly if we are to\npreserve blockchain compatibility. Therefore we need an interim solution until\nsoft upgrades are specified and implemented in Tendermint. This somewhat "),n("em",[e._v("unsafe")]),e._v("\nsolution consists in Tendermint assuming same-block execution if the Application\nfills the above mentioned fields in "),n("code",[e._v("ResponsePrepareProposal")]),e._v(".")]),e._v(" "),n("h2",{attrs:{id:"tendermint-timeouts-in-same-block-execution"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tendermint-timeouts-in-same-block-execution"}},[e._v("#")]),e._v(" Tendermint timeouts in same-block execution")]),e._v(" "),n("p",[e._v("The new same-block execution mode requires the Application to fully execute the\nprepared block at "),n("code",[e._v("PrepareProposal")]),e._v(" time. This execution is synchronous, so\nTendermint cannot make progress until the Application returns from "),n("code",[e._v("PrepareProposal")]),e._v(".\nThis stands on Tendermint's critical path: if the Application takes a long time\nexecuting the block, the default value of "),n("em",[e._v("TimeoutPropose")]),e._v(" might not be sufficient\nto accomodate the long block execution time and non-proposer processes might time\nout and prevote "),n("code",[e._v("nil")]),e._v(", thus starting a further round unnecessarily.")]),e._v(" "),n("p",[e._v("The Application is the best suited to provide a value for "),n("em",[e._v("TimeoutPropose")]),e._v(" so\nthat the block execution time upon "),n("code",[e._v("PrepareProposal")]),e._v(" fits well in the propose\ntimeout interval.")]),e._v(" "),n("p",[e._v("Currently, the Application can override the value of "),n("em",[e._v("TimeoutPropose")]),e._v(" via the\n"),n("code",[e._v("config.toml")]),e._v(" file. In the future, "),n("code",[e._v("ConsensusParams")]),e._v(" may have an extra field\nwith the current "),n("em",[e._v("TimeoutPropose")]),e._v(" value so that the Application has the possibility\nto adapt it at every height.")]),e._v(" "),n("h2",{attrs:{id:"state-sync"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#state-sync"}},[e._v("#")]),e._v(" State Sync")]),e._v(" "),n("p",[e._v("State sync allows new nodes to rapidly bootstrap by discovering, fetching, and applying\nstate machine snapshots instead of replaying historical blocks. For more details, see the\n"),n("RouterLink",{attrs:{to:"/spec/p2p/messages/state-sync.html"}},[e._v("state sync section")]),e._v(".")],1),e._v(" "),n("p",[e._v("New nodes will discover and request snapshots from other nodes in the P2P network.\nA Tendermint node that receives a request for snapshots from a peer will call\n"),n("code",[e._v("ListSnapshots")]),e._v(" on its Application to retrieve any local state snapshots. After receiving\nsnapshots from peers, the new node will offer each snapshot received from a peer\nto its local Application via the "),n("code",[e._v("OfferSnapshot")]),e._v(" method.")]),e._v(" "),n("p",[e._v('Snapshots may be quite large and are thus broken into smaller "chunks" that can be\nassembled into the whole snapshot. Once the Application accepts a snapshot and\nbegins restoring it, Tendermint will fetch snapshot "chunks" from existing nodes.\nThe node providing "chunks" will fetch them from its local Application using\nthe '),n("code",[e._v("LoadSnapshotChunk")]),e._v(" method.")]),e._v(" "),n("p",[e._v('As the new node receives "chunks" it will apply them sequentially to the local\napplication with '),n("code",[e._v("ApplySnapshotChunk")]),e._v(". When all chunks have been applied, the\nApplication's "),n("code",[e._v("AppHash")]),e._v(" is retrieved via an "),n("code",[e._v("Info")]),e._v(" query. The "),n("code",[e._v("AppHash")]),e._v(" is then\ncompared to the blockchain's "),n("code",[e._v("AppHash")]),e._v(" which is verified via\n"),n("RouterLink",{attrs:{to:"/spec/light-client/verification/"}},[e._v("light client verification")]),e._v(".")],1)],1)}),[],!1,null,null,null);t.default=i.exports}}]);